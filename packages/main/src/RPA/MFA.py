import logging
from enum import Enum
from typing import List, Optional

from pyotp import HOTP, TOTP
from requests_oauthlib import OAuth2Session
from robot.api.deco import keyword

from RPA.Robocorp.Vault import Vault
from RPA.Robocorp.utils import protect_keywords


class OTPMode(Enum):
    """Enumeration for type of OTP to use."""

    TIME = "TIME"
    COUNTER = "COUNTER"


class TOTPNotSetError(Exception):
    """Raised when TOTP (Time-based One-Time Password) has not been set."""

    ERROR_MSG = (
        "TOTP (Time-based One-Time Password) can be set during the library "
        "initialization. With `Use MFA Secret From Vault` keyword or with "
        "`Set Time Based OTP` keyword."
    )


class HOTPNotSetError(Exception):
    """Raised when HOTP (HMAC One-Time Password) has not been set."""

    ERROR_MSG = (
        "HOTP (HMAC One-Time Password) can be set during the library "
        "initialization. With `Use MFA Secret From Vault` keyword or with "
        "`Set Counter Based OTP` keyword."
    )


class OAuth2NotSetError(Exception):
    """Raised when OAuth2 session object isn't initialized but used."""

    ERROR_MSG = (
        "OAuth2 session required but not initialized, please call the "
        "`Generate OAuth URL` keyword first."
    )


class MFA:
    """*RPA.MFA* is a library intended mainly for generating one-time passwords (OTP).

    Added on **rpaframework** version: 19.3.0

    Based on the `pyotp <https://pypi.org/project/pyotp/>`_ package.

    In the below example the **mfa** secret we are reading from the Robocorp
    Vault is the passcode generated by the Authenticator service. The passcode
    value is stored into the Vault with key **otpsecret**.

    Passcode is typically a long string (16-32 characters), which is provided
    in a form of QR image, but it can be obtained by requesting access to a string.

    Note that same code can be used to add a mobile phone as a authentication
    device at the same as the same code is added into the Vault.

    **Robot framework example usage:**

    .. code-block:: robotframework

        *** Settings ***
        Library     RPA.Robocorp.Vault
        Library     RPA.MFA


        *** Tasks ***
        Generate time based code
            ${secrets}=    Get Secret   mfa
            ${code}=    Get Time Based OTP    ${secrets}[otpsecret]


    **Python example usage**

    .. code-block:: python

        from RPA.Robocorp.Vault import Vault
        from RPA.MFA import MFA


        def main():
            secrets = Vault().get_secret("mfa")
            code = MFA().get_time_based_otp(secrets["otpsecret"])
    """

    ROBOT_LIBRARY_SCOPE = "GLOBAL"
    ROBOT_LIBRARY_DOC_FORMAT = "REST"

    def __init__(
        self,
        vault_name: Optional[str] = None,
        vault_key: Optional[str] = None,
        mode: Optional[OTPMode] = OTPMode.TIME,
    ):
        protect_keywords("RPA.MFA", ["get_oauth_token", "refresh_oauth_token"])
        self.logger = logging.getLogger(__name__)

        self._hotp: Optional[HOTP] = None
        self._totp: Optional[TOTP] = None
        if vault_name and vault_key:
            self.use_mfa_secret_from_vault(vault_name, vault_key, mode)
        self._oauth: Optional[OAuth2Session] = None

    @keyword
    def use_mfa_secret_from_vault(
        self, vault_name: str, vault_key: str, mode: OTPMode = OTPMode.TIME
    ):
        """Set `time` or `counter` based OTP with passcode stored in
        the Robocorp Vault named with `vault_name` under key of `vault_key`.

        :param vault_name: name of the vault storing the passcode
        :param vault_key: name of the vault key storing the passcode value
        """
        secrets = Vault().get_secret(vault_name)
        if mode == OTPMode.TIME:
            self.set_time_based_otp(secrets[vault_key])
        elif mode == OTPMode.COUNTER:
            self.set_counter_based_otp(secrets[vault_key])

    @keyword
    def set_time_based_otp(self, otp_passcode: str):
        """Set `time` based OTP with passcode.

        :param otp_passcode: the passcode provided by the Authenticator
        """
        self._totp = TOTP(otp_passcode)

    @keyword
    def set_counter_based_otp(self, otp_passcode: str):
        """Set `counter` based OTP with passcode.

        :param otp_passcode: the passcode provided by the Authenticator
        """
        self._hotp = HOTP(otp_passcode)

    @keyword
    def get_time_based_otp(self, otp_passcode: Optional[str] = None):
        """Get `time` based one time password using separately set
        passcode or by parameter `otp_passcode`.

        :param otp_passcode: the passcode provided by the Authenticator
        """
        if otp_passcode:
            self.set_time_based_otp(otp_passcode)
        if not self._totp:
            raise TOTPNotSetError(TOTPNotSetError.ERROR_MSG)
        return self._totp.now()

    @keyword
    def get_counter_based_otp(
        self,
        counter: int,
        otp_passcode: Optional[str] = None,
    ):
        """Get `counter` based one time password using separately set
        passcode or by parameter `otp_passcode`. The counter index is
        given by the `counter` parameter.

        :param counter: the index of the counter
        :param otp_passcode: the passcode provided by the Authenticator
        """
        if otp_passcode:
            self.set_counter_based_otp(otp_passcode)
        if not self._hotp:
            raise HOTPNotSetError(HOTPNotSetError.ERROR_MSG)
        return self._hotp.at(counter)

    @property
    def oauth(self) -> OAuth2Session:
        """Raises if there's no OAuth2 session already created."""
        if not self._oauth:
            raise OAuth2NotSetError(OAuth2NotSetError.ERROR_MSG)

        return self._oauth

    @keyword
    def generate_oauth_url(
        self, auth_url: str, *, client_id: str, redirect_uri: str, scope: str, **kwargs
    ) -> str:
        """Generates an authorization URL which must be opened by the user to start the
        OAuth2 flow and obtain an authorization code as response.

        The received response URL should be passed further with ``Get OAuth Token`` in
        order to complete the flow. Arbitrary keyword arguments can be passed to the
        keyword, which will be redirected to the wrapped `oauthlib` library.

        :param auth_url: Authorization endpoint to call the request on. (https URL
            usually ending with '/authorize')
        :param client_id: Client app ID. (generated by the provider)
        :param redirect_uri: Redirect URL allowed by the Client app configuration. (
            necessary for getting the `code` response)
        :param scope: Space-separated string of permissions. (accepted during the
            consent screen)

        **Example: Robot Framework**

        .. code-block:: robotframework

            *** Tasks ***
            Start OAuth Flow
                ${url} =    Generate OAuth URL
                ...     https://accounts.google.com/o/oauth2/auth
                ...     client_id=810482312368-19htmcgcj*******googleusercontent.com
                ...     redirect_uri=https://developers.google.com/oauthplayground
                ...     scope=https://mail.google.com

        **Example: Python**

        .. code-block:: python

            from RPA.MFA import MFA

            lib_mfa = MFA()
            lib_mfa.generate_oauth_url(https://accounts.google.com/o/oauth2/auth, ...)
        """
        scopes: List[str] = scope.split()
        self._oauth = OAuth2Session(client_id, redirect_uri=redirect_uri, scope=scopes)
        authorization_url, _ = self.oauth.authorization_url(auth_url, **kwargs)
        return authorization_url

    @keyword
    def get_oauth_token(
        self, token_url: str, *, client_secret: str, response_url: str, **kwargs
    ) -> dict:
        """Exchanges the code obtained previously with `Generate OAuth URL` for a
        token.

        :param client_secret: Client app secret. (generated by the provider)
        """
        token = self.oauth.fetch_token(
            token_url,
            client_secret=client_secret,
            authorization_response=response_url,
            **kwargs,
        )
        return dict(token)

    @keyword
    def refresh_oauth_token(
        self,
        token_url: str,
        *,
        client_id: Optional[str] = None,
        client_secret: str,
        refresh_token: Optional[str] = None,
        **kwargs,
    ) -> dict:
        self._oauth = self._oauth or OAuth2Session(client_id)
        token = self.oauth.refresh_token(
            token_url,
            client_id=client_id,
            client_secret=client_secret,
            refresh_token=refresh_token,
            **kwargs,
        )
        return dict(token)
